#pragma once

#include <iostream>
#include <vector>
#include <array>

#include "referee.h"

using grid = std::vector<std::vector<std::string>>;
using coordinates = std::vector<std::array<int, 2>>;

class AI {

    public:

        struct BoardState {

            /**
             * @brief Constructor for the BoardState struct.
             *
             * @param board A board state
             * @param last_placed The coordinates of the last placed piece for the state
             */
            BoardState(const grid& board, const std::array<int, 2>& last_placed);

            grid board;
            std::array<int, 2> last_placed;
        };


        /**
         * @brief Constructor for the AI class.
         *
         * @param board The current board state
         * @param last_placed The coordinates of the last placed piece
         */
        AI(const grid& board, const Referee& referee);

        /**
         * @brief Calls the minimax function to get the AI's next move.
         * @return The AI's next move
         */
        std::array<int, 2> get_ai_move();

        /**
         * @brief Determines the value of a board state by subtracting player 2's score
         * from player 1's score.
         *
         * @param state The board state to be evaluated
         * @return An array containing the value of the state and the coordinates of the
         * last placed piece
         */
        std::array<int, 3> retrieve_board_value(const BoardState& state);

        /**
         * @brief Makes the possible moves generated by the `possible_moves` function.
         *
         * @param state The board state that the copies will be made from
         * @param coords The list of possible coordinates a stone can go
         * @param stone The current player's stone
         *
         * @return The list of possible moves that are valid
         */
        std::vector<BoardState> make_possible_moves(const BoardState& state,
                                                    const coordinates& coords,
                                                    const std::string& stone);

        /**
         * @brief Generates the possible moves that can be made from the last placed
         * piece.
         *
         * Ex: (0, 0) --> (0, 1) and (1, 0) are possibilities
         *
         * After the possible coordinates are determined, they are passed into another
         * function that checks whether the move is actually valid.
         *
         * @param state The board state to have its possible moves determined
         * @param stone The player's stone whose move we are simulating
         *
         * @return The possible
         */
        std::vector<BoardState> generate_moves(const BoardState& state,
                                               const std::string& stone);

        /**
         * @brief The Minimax algorithm
         *
         * This function allow for the AI to determine the best move it can possibly make
         * from a provided board state.
         *
         * In this implementation of the Minimax algorithm, Alpha-Beta pruning is
         * incorperated to increase overall performance.
         *
         * @param state The board state to be evaluated
         * @param depth The number of moves we are looking ahead
         * @param alpha The alpha value of a node (default: -infinity)
         * @param beta The beta value of a node (default: infinity)
         * @param ai_turn If it is the AI's move
         *
         * @return An array with the following contents: [state value, x placed, y placed]
         */
        std::array<int, 3> minimax(const BoardState& state, int depth, int alpha,
                                   int beta, bool ai_turn);


    private:

        BoardState m_current_state;
        Referee m_referee;
};
